{"extracted_information": "The provided web content comprehensively covers content scripts in Chrome Extensions, detailing their capabilities, execution contexts, various injection strategies, communication methods, and security best practices.", "specifications": {}, "pricing": {}, "features": [{"name": "Content Script Capabilities", "description": "Content scripts run in the context of web pages, using the DOM to read, change web page details, and pass information to their parent extension. They can directly access `dom`, `i18n`, `storage`, and specific `runtime` APIs (`connect()`, `getManifest()`, `getURL()`, `id`, `onConnect`, `onMessage`, `sendMessage()`). Other APIs can be accessed indirectly via message passing with other extension parts. They can also access extension files (e.g., using `fetch()`) if declared as web-accessible resources."}, {"name": "Execution Contexts (Isolated Worlds)", "description": "Content scripts live in an 'isolated world', meaning their JavaScript environment is separate from the web page's JavaScript and other content scripts, preventing conflicts. The default 'world' for script execution is `ISOLATED`."}, {"name": "Communication with Embedding Page", "description": "Despite isolated environments, content scripts and web pages share access to the DOM. Communication between them, or between the page and the extension (via the content script), must occur through the shared DOM, typically using `window.postMessage()`."}, {"name": "Accessing Extension Files", "description": "Content scripts can access extension files (images, fonts, etc.) using `chrome.runtime.getURL()` for JavaScript or `chrome-extension://__MSG_@@extension_id__/` for CSS. All such assets must be declared as web-accessible resources in `manifest.json`."}], "statistics": {}, "temporal_info": {"last_updated": "2012-09-17 UTC", "dynamic_declarations_introduced": "Chrome 96"}, "geographical_data": {}, "references": [], "injection_strategies": {"static_declarations": {"description": "Declared in `manifest.json` under the `\"content_scripts\"` key for scripts that run automatically on well-known pages. Includes JavaScript and CSS files, requiring `matches` patterns.", "manifest_properties": [{"name": "matches", "type": "array of strings", "description": "Required. Specifies pages for injection. See Match Patterns."}, {"name": "css", "type": "array of strings", "description": "Optional. CSS files injected in order, before DOM construction/display."}, {"name": "js", "type": "array of strings", "description": "Optional. JavaScript files injected in order. Relative paths to extension root."}, {"name": "run_at", "type": "RunAt", "description": "Optional. When the script injects. Defaults to `document_idle`."}, {"name": "match_about_blank", "type": "boolean", "description": "Optional. Inject into `about:blank` frames if parent/opener matches. Defaults false."}, {"name": "match_origin_as_fallback", "type": "boolean", "description": "Optional. Inject in frames created by matching origin, even if URL doesn't match directly (e.g., `about:`, `data:`, `blob:`, `filesystem:` URLs). Requires `*` path in `matches` for clarity."}, {"name": "world", "type": "ExecutionWorld", "description": "Optional. JavaScript world for execution. Defaults to `ISOLATED`."}]}, "dynamic_declarations": {"description": "Useful when match patterns are not well known or injection is conditional. Registered, retrieved, updated, and removed using methods in the `chrome.scripting` namespace (e.g., `registerContentScripts`, `getRegisteredContentScripts`, `updateContentScripts`, `unregisterContentScripts`). Similar to static declarations, supporting JS/CSS files.", "scripting_api_methods": ["chrome.scripting.registerContentScripts()", "chrome.scripting.getRegisteredContentScripts()", "chrome.scripting.updateContentScripts()", "chrome.scripting.unregisterContentScripts()"]}, "programmatic_injection": {"description": "For scripts that run in response to events or on specific occasions. Requires host permissions (via manifest or `activeTab`). Scripts can be injected as files or as a function body using `chrome.scripting.executeScript()`. Injected functions are copies and must be self-contained; arguments can be passed.", "methods": ["Injecting files: `chrome.scripting.executeScript({ target: { tabId: tab.id }, files: ['content-script.js'] })`", "Injecting function bodies: `chrome.scripting.executeScript({ target: { tabId: tab.id }, func: injectedFunction, args: ['arg1'] })`"]}, "matching_and_exclusion": {"description": "Customizes page matching for declarative registrations.", "properties": [{"name": "exclude_matches", "type": "array of strings", "description": "Optional. Excludes pages that would otherwise be injected."}, {"name": "include_globs", "type": "array of strings", "description": "Optional. Emulates Greasemonkey `@include`. Applied after `matches` to include URLs matching glob patterns (e.g., `*` for any string, `?` for any single character)."}, {"name": "exclude_globs", "type": "array of string", "description": "Optional. Emulates Greasemonkey `@exclude`. Applied after `matches` to exclude URLs matching glob patterns."}], "logic": "Content script injected if URL matches `matches` AND `include_globs`, AND does NOT match `exclude_matches` OR `exclude_globs`."}, "run_time_control": {"property": "run_at", "description": "Controls when JavaScript files are injected.", "values": [{"value": "document_idle", "description": "Preferred default. Browser chooses injection time between `document_end` and immediately after `window.onload`, optimized for page load speed. Guarantees DOM is complete."}, {"value": "document_start", "description": "Scripts injected after CSS, before any DOM construction or other scripts."}, {"value": "document_end", "description": "Scripts injected immediately after DOM is complete, but before subresources load."}]}, "frame_specification": {"description": "Determines if scripts inject into all frames or only the topmost frame.", "properties": [{"name": "all_frames", "type": "boolean", "description": "In declarative manifest or `chrome.scripting.registerContentScripts`, specifies if JS/CSS injects into all frames matching URL requirements or only top frame. Cannot be used with `frameIds` or `documentIds` in programmatic injection."}], "related_frames_injection": {"property": "match_origin_as_fallback", "value": "true", "description": "When true, Chrome checks the origin of the frame's initiator (creator/navigator) to determine if the frame matches, rather than the frame's own URL. Useful for frames with `about:`, `data:`, `blob:`, and `filesystem:` schemes whose URLs don't directly match patterns. Requires a path of `*` in `matches`."}}}, "security_and_best_practices": {"security_vulnerabilities": "Content scripts can create vulnerabilities if not handled carefully. Receiving content from external websites (e.g., via `fetch()`) requires filtering against Cross-Site Scripting (XSS) attacks. Only communicate over HTTPS to avoid 'man-in-the-middle' attacks.", "disallowed_practices_manifest_v3": ["Evaluating untrusted strings with `eval()`.", "Using string-based arguments for `window.setTimeout()` or `window.setInterval()`."], "safer_alternatives": ["Use `JSON.parse()` for parsing JSON data, which does not evaluate scripts.", "Use closure forms for `setTimeout()` and `setInterval()` (e.g., `window.setTimeout(() => animate(elmt_id), 200)`), which do not evaluate scripts."]}}